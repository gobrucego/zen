# 第14天：第一阶段总结与综合实战

> "前两周的学习为你打开了网络世界的大门，现在是时候检验学习成果了！"

## 📚 今日目标

- 回顾第一阶段核心知识点
- 完成综合实战项目
- 掌握网络问题排查方法
- 为下一阶段做好准备

---

## 1. 第一阶段学习回顾（Day 1-13）

### 1.1 知识地图

```
第一阶段：网络基础入门
│
├── 第1周：网络基础概念
│   ├── Day 1: 计算机网络概述
│   │   ├── 什么是计算机网络
│   │   ├── 网络的作用
│   │   └── 网络连接检测工具
│   │
│   ├── Day 2: 网络分类和拓扑
│   │   ├── LAN/WAN/MAN
│   │   ├── 五种拓扑结构
│   │   └── 局域网扫描器
│   │
│   ├── Day 3: OSI七层模型
│   │   ├── 七层模型详解
│   │   ├── 数据封装过程
│   │   └── 协议分层演示
│   │
│   ├── Day 4: TCP/IP四层模型
│   │   ├── TCP/IP vs OSI
│   │   ├── 四层模型详解
│   │   └── 数据包分析
│   │
│   ├── Day 5: ping命令
│   │   ├── ping原理
│   │   ├── ICMP协议
│   │   └── 简易ping工具
│   │
│   ├── Day 6: traceroute命令
│   │   ├── traceroute原理
│   │   ├── TTL字段
│   │   └── traceroute工具
│   │
│   └── Day 7: Wireshark抓包
│       ├── Wireshark基础
│       ├── 过滤器语法
│       └── HTTP请求分析
│
└── 第2周：网络层深入理解
    ├── Day 8: IP地址基础
    │   ├── IPv4地址结构
    │   ├── IP地址分类
    │   └── IP地址分析工具
    │
    ├── Day 9: 子网划分
    │   ├── 子网掩码
    │   ├── CIDR表示法
    │   └── 子网计算器
    │
    ├── Day 10: MAC地址和ARP
    │   ├── MAC地址结构
    │   ├── ARP协议
    │   └── ARP扫描工具
    │
    ├── Day 11: 端口和Socket
    │   ├── 端口概念
    │   ├── Socket基础
    │   └── 端口扫描器
    │
    ├── Day 12: DNS协议
    │   ├── DNS工作原理
    │   ├── DNS查询流程
    │   └── DNS查询工具
    │
    └── Day 13: DHCP协议
        ├── DHCP原理
        ├── DORA四次握手
        └── DHCP分析工具
```

---

## 2. 核心知识点总结

### 2.1 OSI七层模型 vs TCP/IP四层模型

```
OSI七层模型              TCP/IP四层模型        协议示例
┌────────────────┐
│  7. 应用层      │      ┌──────────┐         HTTP, FTP, DNS
│  6. 表示层      │──────│ 应用层    │         SMTP, SSH, Telnet
│  5. 会话层      │      └──────────┘
├────────────────┤      ┌──────────┐
│  4. 传输层      │──────│ 传输层    │         TCP, UDP
├────────────────┤      └──────────┘
│  3. 网络层      │      ┌──────────┐
├────────────────┤──────│ 网络层    │         IP, ICMP, ARP
│  2. 数据链路层   │      └──────────┘
├────────────────┤      ┌──────────┐
│  1. 物理层      │──────│ 链路层    │         Ethernet, WiFi
└────────────────┘      └──────────┘

数据封装过程：
应用数据
  → 添加TCP/UDP头（传输层）
    → 添加IP头（网络层）
      → 添加以太网帧头/尾（链路层）
        → 转换为比特流（物理层）
```

### 2.2 IP地址和子网划分

**IP地址分类**：
```
类别    范围                    默认掩码          用途
A    1.0.0.0 - 126.255.255.255    /8 (255.0.0.0)        大型网络
B    128.0.0.0 - 191.255.255.255  /16 (255.255.0.0)     中型网络
C    192.0.0.0 - 223.255.255.255  /24 (255.255.255.0)   小型网络

私有IP：
10.0.0.0/8         (10.0.0.0 - 10.255.255.255)
172.16.0.0/12      (172.16.0.0 - 172.31.255.255)
192.168.0.0/16     (192.168.0.0 - 192.168.255.255)

特殊IP：
127.0.0.1          环回地址（本机）
0.0.0.0            所有地址/未知地址
255.255.255.255    广播地址
```

**子网划分快速计算**：
```
CIDR    掩码              主机数    子网数（从/24划分）
/24     255.255.255.0     254       1
/25     255.255.255.128   126       2
/26     255.255.255.192   62        4
/27     255.255.255.224   30        8
/28     255.255.255.240   14        16
/29     255.255.255.248   6         32
/30     255.255.255.252   2         64（用于点对点）

主机数计算：2^(32-CIDR) - 2
```

### 2.3 ARP协议

**ARP工作流程**：
```
场景：主机A (192.168.1.10) 想发送数据给主机B (192.168.1.20)

步骤1：检查ARP缓存
    arp -a
    → 如果有B的MAC地址，直接使用
    → 如果没有，进行ARP请求

步骤2：广播ARP请求
    源MAC: AA:AA:AA:AA:AA:AA (主机A)
    目标MAC: FF:FF:FF:FF:FF:FF (广播)
    内容: "谁是192.168.1.20？请告诉192.168.1.10"

步骤3：目标主机回应
    源MAC: BB:BB:BB:BB:BB:BB (主机B)
    目标MAC: AA:AA:AA:AA:AA:AA (主机A)
    内容: "192.168.1.20是我，我的MAC是BB:BB:BB:BB:BB:BB"

步骤4：更新ARP缓存
    192.168.1.20 → BB:BB:BB:BB:BB:BB (保存在缓存中)

步骤5：发送数据
    现在可以直接发送数据了
```

### 2.4 DNS工作原理

**DNS查询流程**：
```
用户访问 www.example.com

1. 浏览器检查缓存
   浏览器缓存 → 操作系统缓存 → hosts文件

2. 如果缓存未命中，向本地DNS服务器查询
   客户端 → 本地DNS (192.168.1.1)

3. 本地DNS递归查询
   ┌──────────────────────────────────────┐
   │ 本地DNS → 根DNS服务器 (.)            │
   │     "example.com在哪？"              │
   │     ← "去问.com的DNS服务器"          │
   │                                      │
   │ 本地DNS → .com顶级DNS                │
   │     "example.com在哪？"              │
   │     ← "去问example.com的权威DNS"     │
   │                                      │
   │ 本地DNS → example.com权威DNS         │
   │     "www.example.com的IP是？"        │
   │     ← "IP是93.184.216.34"            │
   └──────────────────────────────────────┘

4. 本地DNS返回结果给客户端
   IP: 93.184.216.34

5. 浏览器使用该IP建立连接
   HTTP GET http://93.184.216.34/
```

### 2.5 DHCP工作原理

**DHCP四次握手（DORA）**：
```
D - Discover  发现
O - Offer     提供
R - Request   请求
A - Ack       确认

场景：新电脑接入网络

1. DHCP Discover (广播)
   客户端: "有DHCP服务器吗？我需要IP地址！"
   源IP: 0.0.0.0
   目标IP: 255.255.255.255
   目标MAC: FF:FF:FF:FF:FF:FF

2. DHCP Offer (单播)
   服务器: "我是DHCP服务器，可以给你192.168.1.100"
   提供: IP=192.168.1.100, 掩码=255.255.255.0, 网关=192.168.1.1

3. DHCP Request (广播)
   客户端: "我接受192.168.1.100这个地址"
   （广播是为了告诉其他DHCP服务器这个IP被占用了）

4. DHCP Ack (单播)
   服务器: "确认分配给你192.168.1.100，租期24小时"
   包含: IP、掩码、网关、DNS、租期

配置完成！客户端现在可以上网了。
```

---

## 3. 综合实战项目：网络配置检测工具

### 3.1 项目需求

创建一个命令行工具，能够：
1. 检测本机网络配置
2. 测试网络连通性
3. DNS查询测试
4. 生成诊断报告

### 3.2 代码实现

```python
# day14_network_inspector.py
# 功能：综合网络配置检测工具

import socket
import struct
import subprocess
import platform
import sys
from typing import Dict, List, Tuple

class NetworkInspector:
    """
    网络配置检测工具

    功能：
        1. 获取本机网络配置
        2. 测试网络连通性
        3. DNS解析测试
        4. 生成诊断报告
    """

    def __init__(self):
        self.system = platform.system()
        self.report = []

    def add_to_report(self, section: str, content: str):
        """添加内容到报告"""
        self.report.append(f"\n{'='*60}")
        self.report.append(f" {section}")
        self.report.append('='*60)
        self.report.append(content)

    def get_local_ip(self) -> str:
        """
        获取本机IP地址

        返回值：
            本机IP地址字符串

        工作原理：
            创建UDP socket连接到外部地址（不实际发送数据）
            从socket获取本机使用的IP地址
        """
        try:
            # 创建UDP socket
            s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            # 连接到外部地址（Google DNS）
            s.connect(("8.8.8.8", 80))
            # 获取socket使用的本地IP
            local_ip = s.getsockname()[0]
            s.close()
            return local_ip
        except Exception as e:
            return f"获取失败: {e}"

    def get_hostname(self) -> str:
        """获取主机名"""
        return socket.gethostname()

    def get_network_interfaces(self) -> Dict[str, str]:
        """
        获取网络接口信息

        返回值：
            包含接口信息的字典
        """
        interfaces = {}
        try:
            # 获取主机名对应的所有IP地址
            hostname = socket.gethostname()
            local_ips = socket.gethostbyname_ex(hostname)[2]

            interfaces['主机名'] = hostname
            interfaces['本机IP'] = self.get_local_ip()
            interfaces['所有IP'] = ', '.join(local_ips)

        except Exception as e:
            interfaces['错误'] = str(e)

        return interfaces

    def test_connectivity(self, host: str = "8.8.8.8", port: int = 53) -> Tuple[bool, str]:
        """
        测试网络连通性

        参数：
            host: 目标主机
            port: 目标端口

        返回值：
            (是否连通, 详细信息)
        """
        try:
            # 尝试建立TCP连接
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(3)
            start_time = socket.time.time()
            result = sock.connect_ex((host, port))
            end_time = socket.time.time()
            sock.close()

            if result == 0:
                latency = (end_time - start_time) * 1000  # 转换为毫秒
                return True, f"✅ 连接成功 ({host}:{port}) - 延迟: {latency:.2f}ms"
            else:
                return False, f"❌ 连接失败 ({host}:{port})"
        except Exception as e:
            return False, f"❌ 连接异常: {e}"

    def test_dns(self, domain: str = "www.baidu.com") -> Tuple[bool, str]:
        """
        测试DNS解析

        参数：
            domain: 要解析的域名

        返回值：
            (是否成功, 详细信息)
        """
        try:
            start_time = socket.time.time()
            ip = socket.gethostbyname(domain)
            end_time = socket.time.time()

            query_time = (end_time - start_time) * 1000
            return True, f"✅ DNS解析成功\n   {domain} → {ip}\n   查询时间: {query_time:.2f}ms"
        except socket.gaierror as e:
            return False, f"❌ DNS解析失败: {e}"
        except Exception as e:
            return False, f"❌ DNS查询异常: {e}"

    def get_default_gateway(self) -> str:
        """
        获取默认网关

        返回值：
            默认网关IP地址
        """
        try:
            if self.system == "Windows":
                result = subprocess.run(
                    ['ipconfig'],
                    capture_output=True,
                    text=True
                )
                output = result.stdout
                for line in output.split('\n'):
                    if '默认网关' in line or 'Default Gateway' in line:
                        parts = line.split(':')
                        if len(parts) > 1:
                            gateway = parts[1].strip()
                            if gateway and gateway != '':
                                return gateway
            else:
                # Linux/Mac
                result = subprocess.run(
                    ['ip', 'route'],
                    capture_output=True,
                    text=True
                )
                output = result.stdout
                for line in output.split('\n'):
                    if 'default' in line:
                        parts = line.split()
                        if len(parts) > 2:
                            return parts[2]

            return "未找到"
        except Exception as e:
            return f"获取失败: {e}"

    def run_full_inspection(self):
        """
        运行完整的网络检测

        工作流程：
            1. 获取本机网络配置
            2. 测试本地连通性
            3. 测试外网连通性
            4. 测试DNS解析
            5. 生成诊断报告
        """
        print("\n" + "="*60)
        print(" 网络配置检测工具 - Network Inspector")
        print("="*60)

        # 1. 本机配置
        print("\n[1/5] 正在获取本机网络配置...")
        interfaces = self.get_network_interfaces()
        gateway = self.get_default_gateway()

        config_info = []
        config_info.append(f"主机名:    {interfaces.get('主机名', '未知')}")
        config_info.append(f"本机IP:    {interfaces.get('本机IP', '未知')}")
        config_info.append(f"默认网关:  {gateway}")
        config_info.append(f"操作系统:  {self.system}")

        self.add_to_report("本机网络配置", '\n'.join(config_info))
        for line in config_info:
            print(f"  {line}")

        # 2. 测试网关连通性
        print("\n[2/5] 正在测试网关连通性...")
        if gateway != "未找到" and gateway != "获取失败":
            success, msg = self.test_connectivity(gateway, 80)
            self.add_to_report("网关连通性测试", msg)
            print(f"  {msg}")
        else:
            msg = "❌ 无法获取网关，跳过测试"
            self.add_to_report("网关连通性测试", msg)
            print(f"  {msg}")

        # 3. 测试外网连通性
        print("\n[3/5] 正在测试外网连通性...")
        test_hosts = [
            ("8.8.8.8", 53, "Google DNS"),
            ("114.114.114.114", 53, "114 DNS"),
            ("1.1.1.1", 53, "Cloudflare DNS")
        ]

        connectivity_results = []
        for host, port, name in test_hosts:
            success, msg = self.test_connectivity(host, port)
            connectivity_results.append(f"{name}: {msg}")
            print(f"  {msg}")

        self.add_to_report("外网连通性测试", '\n'.join(connectivity_results))

        # 4. 测试DNS
        print("\n[4/5] 正在测试DNS解析...")
        test_domains = [
            "www.baidu.com",
            "www.google.com",
            "www.github.com"
        ]

        dns_results = []
        for domain in test_domains:
            success, msg = self.test_dns(domain)
            dns_results.append(msg)
            print(f"  {msg}")

        self.add_to_report("DNS解析测试", '\n'.join(dns_results))

        # 5. 生成诊断建议
        print("\n[5/5] 正在生成诊断报告...")
        diagnosis = self.generate_diagnosis()
        self.add_to_report("诊断建议", diagnosis)

    def generate_diagnosis(self) -> str:
        """
        生成诊断建议

        返回值：
            诊断建议字符串
        """
        suggestions = []

        # 检查报告中的问题
        report_text = '\n'.join(self.report)

        if '连接失败' in report_text or '连接异常' in report_text:
            suggestions.append("⚠️  检测到网络连接问题：")
            suggestions.append("   1. 检查网线或WiFi连接")
            suggestions.append("   2. 检查防火墙设置")
            suggestions.append("   3. 尝试重启路由器")

        if 'DNS解析失败' in report_text:
            suggestions.append("\n⚠️  检测到DNS解析问题：")
            suggestions.append("   1. 检查DNS服务器配置")
            suggestions.append("   2. 尝试使用公共DNS (8.8.8.8)")
            suggestions.append("   3. 清除DNS缓存")

        if not suggestions:
            suggestions.append("✅ 网络状态良好，未发现明显问题")

        return '\n'.join(suggestions)

    def print_report(self):
        """打印完整报告"""
        print("\n\n" + "="*60)
        print(" 完整诊断报告")
        print("="*60)

        for section in self.report:
            print(section)

        print("\n" + "="*60)
        print(" 报告结束")
        print("="*60 + "\n")

    def save_report(self, filename: str = "network_report.txt"):
        """
        保存报告到文件

        参数：
            filename: 保存的文件名
        """
        try:
            with open(filename, 'w', encoding='utf-8') as f:
                f.write("网络配置检测报告\n")
                f.write(f"生成时间: {socket.time.ctime()}\n")
                f.write('\n'.join(self.report))
            print(f"\n✅ 报告已保存到: {filename}")
        except Exception as e:
            print(f"\n❌ 保存报告失败: {e}")


def main():
    """主程序"""
    print("""
    ╔══════════════════════════════════════════════════════════╗
    ║       网络配置检测工具 v1.0                               ║
    ║       Network Configuration Inspector                    ║
    ╚══════════════════════════════════════════════════════════╝
    """)

    inspector = NetworkInspector()

    try:
        # 运行完整检测
        inspector.run_full_inspection()

        # 打印报告
        inspector.print_report()

        # 保存报告
        save_option = input("\n是否保存报告到文件？(y/n): ").strip().lower()
        if save_option == 'y':
            filename = input("请输入文件名 (默认: network_report.txt): ").strip()
            if not filename:
                filename = "network_report.txt"
            inspector.save_report(filename)

    except KeyboardInterrupt:
        print("\n\n用户中断程序")
        sys.exit(0)
    except Exception as e:
        print(f"\n❌ 程序异常: {e}")
        sys.exit(1)


if __name__ == "__main__":
    main()
```

### 3.3 运行示例

```bash
# 运行程序
python code/day14/day14_network_inspector.py

输出示例：
╔══════════════════════════════════════════════════════════╗
║       网络配置检测工具 v1.0                               ║
║       Network Configuration Inspector                    ║
╚══════════════════════════════════════════════════════════╝

============================================================
 网络配置检测工具 - Network Inspector
============================================================

[1/5] 正在获取本机网络配置...
  主机名:    DESKTOP-ABC123
  本机IP:    192.168.1.100
  默认网关:  192.168.1.1
  操作系统:  Windows

[2/5] 正在测试网关连通性...
  ✅ 连接成功 (192.168.1.1:80) - 延迟: 1.23ms

[3/5] 正在测试外网连通性...
  ✅ 连接成功 (8.8.8.8:53) - 延迟: 15.67ms
  ✅ 连接成功 (114.114.114.114:53) - 延迟: 12.34ms
  ✅ 连接成功 (1.1.1.1:53) - 延迟: 18.90ms

[4/5] 正在测试DNS解析...
  ✅ DNS解析成功
     www.baidu.com → 39.156.66.10
     查询时间: 45.67ms
  ✅ DNS解析成功
     www.google.com → 172.217.160.68
     查询时间: 23.45ms
  ✅ DNS解析成功
     www.github.com → 20.205.243.166
     查询时间: 34.56ms

[5/5] 正在生成诊断报告...
```

---

## 4. 常见网络问题诊断

### 4.1 问题诊断流程图

```
网络无法访问？
│
├─ 步骤1: 检查物理连接
│   ├─ 网线是否插好？
│   ├─ WiFi是否连接？
│   └─ 网卡指示灯是否亮？
│
├─ 步骤2: 检查IP配置
│   ├─ IP地址: ipconfig / ip addr
│   ├─ 子网掩码正确？
│   ├─ 网关配置正确？
│   └─ DNS服务器配置正确？
│
├─ 步骤3: Ping测试
│   ├─ ping 127.0.0.1 (本机)
│   ├─ ping 网关
│   ├─ ping DNS服务器
│   └─ ping 外网IP (8.8.8.8)
│
├─ 步骤4: DNS测试
│   ├─ nslookup www.baidu.com
│   └─ 检查DNS解析是否正常
│
└─ 步骤5: 路由测试
    └─ traceroute/tracert 检查路径
```

### 4.2 常见问题和解决方案

**问题1：获取不到IP地址（169.254.x.x）**
```
原因：
- DHCP服务器故障
- 网络线路问题
- DHCP服务未启动

解决方法：
1. 重启网卡
   # Windows
   ipconfig /release
   ipconfig /renew

   # Linux
   sudo dhclient -r
   sudo dhclient

2. 检查DHCP服务器
3. 手动配置静态IP
```

**问题2：能Ping通IP但无法访问网站**
```
原因：
- DNS服务器故障
- DNS配置错误

解决方法：
1. 更换DNS服务器
   Windows: 网络适配器设置
   Linux: /etc/resolv.conf

   推荐DNS:
   - 8.8.8.8 (Google)
   - 114.114.114.114 (114DNS)
   - 1.1.1.1 (Cloudflare)

2. 清除DNS缓存
   # Windows
   ipconfig /flushdns

   # Linux
   sudo systemd-resolve --flush-caches
```

**问题3：网速很慢**
```
原因：
- 网络拥堵
- 带宽限制
- DNS解析慢
- 路由问题

诊断方法：
1. 测试带宽
   使用speedtest等工具

2. 检查延迟
   ping -n 100 网关
   检查平均延迟和抖动

3. 追踪路由
   tracert www.baidu.com
   查看哪一跳延迟高

4. 优化DNS
   更换更快的DNS服务器
```

---

## 5. 第一阶段技能清单

完成第一阶段后，你应该掌握：

### 5.1 理论知识
- ✅ 理解OSI七层模型和TCP/IP四层模型
- ✅ 掌握IP地址分类和子网划分
- ✅ 理解MAC地址和ARP协议
- ✅ 掌握DNS和DHCP工作原理
- ✅ 理解端口和Socket概念

### 5.2 工具使用
- ✅ ping - 测试连通性
- ✅ traceroute/tracert - 追踪路由
- ✅ ipconfig/ifconfig - 查看网络配置
- ✅ nslookup/dig - DNS查询
- ✅ arp - 查看ARP缓存
- ✅ Wireshark - 抓包分析

### 5.3 编程能力
- ✅ 使用Python socket库
- ✅ 实现网络连接检测
- ✅ 实现局域网扫描
- ✅ 实现简单的ping和traceroute
- ✅ 实现DNS查询工具

### 5.4 问题排查
- ✅ 系统化的网络问题诊断流程
- ✅ 使用命令行工具排查问题
- ✅ 分析网络配置错误
- ✅ 解决常见网络问题

---

## 6. 今日练习

### 练习1：综合诊断
运行day14的网络检测工具，分析输出结果，回答：
1. 你的本机IP地址是什么？属于哪一类？
2. 默认网关是什么？
3. DNS解析速度如何？
4. 是否存在网络问题？

### 练习2：子网划分
给定网络 192.168.10.0/24，划分为：
1. 4个相等的子网
2. 计算每个子网的网络地址、广播地址、可用IP范围
3. 选择CIDR表示法

### 练习3：故障排查
假设场景：
- 能ping通192.168.1.1（网关）
- 能ping通8.8.8.8
- 无法访问www.baidu.com

请使用所学的诊断方法，找出问题原因并给出解决方案。

### 练习4：抓包分析
使用Wireshark：
1. 抓取一次完整的DHCP四次握手
2. 分析每个数据包的内容
3. 识别DORA四个阶段
4. 截图标注关键信息

---

## 7. 扩展学习

### 7.1 推荐阅读
- RFC 791: Internet Protocol (IP)
- RFC 826: Address Resolution Protocol (ARP)
- RFC 792: Internet Control Message Protocol (ICMP)
- RFC 2131: Dynamic Host Configuration Protocol (DHCP)
- RFC 1035: Domain Names - Implementation and Specification (DNS)

### 7.2 在线资源
- Wireshark官方教程
- 子网划分在线计算器
- 网络协议分析案例

### 7.3 实践建议
1. 搭建虚拟实验环境（VirtualBox + 多台虚拟机）
2. 配置不同的网络拓扑
3. 模拟各种网络故障
4. 练习问题诊断和解决

---

## 8. 下一阶段预告

### 第二阶段：应用层协议深入（Day 15-27）

**第3周：传输层协议基础**
- TCP协议详解
- TCP可靠传输机制
- UDP协议
- Socket编程

**第4周：网络层协议深入**
- IP协议深入
- IPv6
- ICMP详解
- 路由协议基础

学习重点：
- 深入理解TCP/IP核心协议
- 掌握Socket网络编程
- 学习网络层路由机制
- 完成更复杂的实战项目

---

## 9. 总结

```
第一阶段学习路径：

网络基础概念 → 协议分层模型 → 诊断工具
       ↓              ↓            ↓
   网络拓扑        OSI/TCP-IP     ping/traceroute
                      ↓
              IP地址和子网划分
                      ↓
              MAC地址和ARP
                      ↓
              DNS和DHCP
                      ↓
           综合实战：网络诊断工具

核心能力：
✅ 网络基础理论
✅ 协议工作原理
✅ 工具使用
✅ 编程实现
✅ 问题诊断

学习心得：
网络基础是所有网络技术的根基。
理解了IP地址、子网划分、ARP、DNS这些基础概念，
就像掌握了网络世界的"字母表"。

接下来我们将深入传输层和网络层，
学习TCP/IP协议栈的核心机制。

继续加油！💪
```

---

**进度：14/120天（11.7%）**

恭喜完成第一阶段学习！你已经建立了扎实的网络基础知识。接下来的学习将更加深入和精彩，让我们继续前进！

---

## 附录：常用命令速查表

### Windows命令
```bash
ipconfig /all              # 查看详细网络配置
ipconfig /release          # 释放DHCP分配的IP
ipconfig /renew            # 重新获取IP
ipconfig /flushdns         # 清除DNS缓存
ipconfig /displaydns       # 显示DNS缓存

ping <IP>                  # 测试连通性
ping -t <IP>              # 持续ping
tracert <域名>             # 追踪路由
nslookup <域名>            # DNS查询
arp -a                     # 查看ARP缓存
netstat -an               # 查看网络连接
route print               # 查看路由表
```

### Linux/Mac命令
```bash
ip addr show              # 查看网络配置
ip route show             # 查看路由表
ifconfig                  # 查看网络接口（旧）

ping <IP>                 # 测试连通性
ping -c 4 <IP>           # ping 4次
traceroute <域名>         # 追踪路由
dig <域名>                # DNS查询（详细）
nslookup <域名>           # DNS查询（简单）

arp -a                    # 查看ARP缓存
netstat -an              # 查看网络连接
ss -tulpn                # 查看监听端口

sudo dhclient -r         # 释放IP
sudo dhclient            # 获取IP
sudo systemd-resolve --flush-caches  # 清除DNS缓存
```
