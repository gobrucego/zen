# 第23天：IPv6详解

## 今日目标

- 理解IPv6产生的背景和必要性
- 掌握IPv6地址格式和表示方法
- 学习IPv6特性和优势
- 了解IPv6报文格式
- 理解IPv6地址类型
- 学习IPv6过渡技术
- 实现IPv6地址解析工具

---

## 1. IPv6概述

### 1.1 为什么需要IPv6？

**IPv4地址耗尽**：

```
IPv4地址空间：
- 32位地址
- 总数：2^32 = 4,294,967,296 ≈ 43亿个
- 实际可用：更少（保留地址、私有地址等）

全球需求：
- 全球人口：约80亿
- 每人多设备：手机、电脑、平板、手表...
- 物联网设备：数百亿
- 明显不够用！

地址耗尽时间线：
- 2011年：IANA分配完最后的IPv4地址块
- 2012-2019：各地区陆续耗尽
- 现状：依赖NAT等技术缓解
```

**NAT的局限性**：

```
NAT虽然缓解了地址短缺，但带来问题：

❌ 破坏端到端连接性
❌ 增加复杂度和延迟
❌ P2P应用困难
❌ 需要维护状态表
❌ 违反分层原则
❌ 某些协议不支持

IPv6是根本解决方案
```

### 1.2 IPv6的优势

**核心优势**：

```
1. 巨大的地址空间
   ✅ 128位地址
   ✅ 2^128 ≈ 340万亿亿亿亿个
   ✅ 足够用几百年

2. 简化的报文头部
   ✅ 固定40字节（IPv4为20-60字节）
   ✅ 提高路由效率
   ✅ 扩展头部机制

3. 更好的移动性
   ✅ 移动IPv6
   ✅ 无需NAT
   ✅ 更快的切换

4. 内置安全性
   ✅ IPSec是强制的
   ✅ 端到端加密

5. 更好的QoS支持
   ✅ 流标签
   ✅ 优先级

6. 无需NAT
   ✅ 端到端连接
   ✅ 简化网络
   ✅ 更好的性能

7. 自动配置
   ✅ 无状态地址自动配置（SLAAC）
   ✅ 即插即用
   ✅ 简化管理

8. 更好的多播
   ✅ 改进的多播路由
   ✅ 任播支持
```

---

## 2. IPv6地址格式

### 2.1 地址表示

**基本格式**：

```
IPv6地址：128位 = 16字节

表示方法：
- 8个16位字段
- 每个字段用4个十六进制数表示
- 用冒号分隔

完整格式：
2001:0db8:0000:0000:0000:ff00:0042:8329

说明：
2001 : 0db8 : 0000 : 0000 : 0000 : ff00 : 0042 : 8329
  ↓      ↓      ↓      ↓      ↓      ↓      ↓      ↓
 16位   16位   16位   16位   16位   16位   16位   16位
```

**地址压缩规则**：

```
规则1：前导零压缩
可以省略每个字段的前导零

示例：
2001:0db8:0000:0000:0000:ff00:0042:8329
↓
2001:db8:0:0:0:ff00:42:8329

规则2：零压缩
连续的零字段可以用 :: 表示
但一个地址中只能使用一次 ::

示例：
2001:db8:0:0:0:ff00:42:8329
↓
2001:db8::ff00:42:8329

错误示例：
2001:0:0:0:0:0:0:1
不能写成：2001::0::1  ❌（两个::）
应该写成：2001::1     ✅
```

**特殊地址表示**：

```
未指定地址：
0:0:0:0:0:0:0:0
或 ::

环回地址：
0:0:0:0:0:0:0:1
或 ::1

IPv4映射地址：
::ffff:192.168.1.1
前96位为0，后32位为IPv4地址
```

### 2.2 IPv6地址结构

**地址组成**：

```
IPv6地址 = 前缀 + 接口标识符

常见结构（64位前缀）：
┌─────────────────────────┬─────────────────────────┐
│    前缀（64位）          │   接口标识符（64位）     │
│   网络部分               │    主机部分             │
└─────────────────────────┴─────────────────────────┘

前缀分配：
┌──────┬──────────┬────────────┬─────────────────────┐
│ /48  │   /56    │    /64     │      接口ID         │
│ 站点 │  子网    │  链路      │     主机            │
└──────┴──────────┴────────────┴─────────────────────┘
```

**前缀表示**：

```
IPv6前缀表示：
地址/前缀长度

示例：
2001:db8::/32
- 网络地址：2001:db8::
- 前缀长度：32位

常见前缀长度：
/32 - ISP分配
/48 - 组织/站点
/56 - 小型组织
/64 - 单个链路（最常用）
/128 - 单个主机
```

### 2.3 IPv6地址类型

**单播地址（Unicast）**：

```
单播 = 一对一通信

类型：

1. 全局单播地址（Global Unicast Address）
   - 前缀：2000::/3（2开头或3开头）
   - 相当于IPv4的公网地址
   - 全球唯一，可路由
   - 示例：2001:db8::1

2. 链路本地地址（Link-Local Address）
   - 前缀：fe80::/10
   - 只在本地链路有效
   - 不能路由
   - 自动配置
   - 相当于IPv4的169.254.0.0/16
   - 示例：fe80::1

3. 唯一本地地址（Unique Local Address，ULA）
   - 前缀：fc00::/7（实际使用fd00::/8）
   - 相当于IPv4的私有地址
   - 本地路由，不在互联网路由
   - 示例：fd12:3456:789a::1

4. 环回地址（Loopback）
   - 地址：::1
   - 相当于IPv4的127.0.0.1

5. 未指定地址
   - 地址：::
   - 相当于IPv4的0.0.0.0
   - 表示"无地址"
```

**任播地址（Anycast）**：

```
任播 = 发送给多个接口中最近的一个

特点：
- 多个节点共享相同地址
- 数据包发送给最近的节点
- 用于负载均衡

使用：
- 相同格式的单播地址
- 通过路由配置实现

应用场景：
- DNS根服务器
- CDN
- 负载均衡
```

**多播地址（Multicast）**：

```
多播 = 一对多通信

前缀：ff00::/8

格式：
ff<flags><scope>:....

Flags：
- 0：永久分配
- 1：临时分配

Scope（范围）：
- 1：接口本地
- 2：链路本地
- 5：站点本地
- 8：组织本地
- e：全球

常用多播地址：
ff02::1  - 所有节点（链路本地）
ff02::2  - 所有路由器（链路本地）
ff02::1:ff00:0/104 - 请求节点多播地址
```

**IPv6没有广播**：

```
IPv6取消了广播

原因：
- 广播效率低
- 占用带宽
- 影响所有节点

替代方案：
使用多播
更精确，更高效
```

### 2.4 特殊地址

```
::1/128
- 环回地址
- 本地主机

::/128
- 未指定地址
- 没有地址时使用

fe80::/10
- 链路本地地址
- 自动配置

ff00::/8
- 多播地址

2001:db8::/32
- 文档地址
- 仅用于文档和示例
- 不能在互联网路由

::ffff:0:0/96
- IPv4映射地址
- 表示IPv4地址

64:ff9b::/96
- IPv4/IPv6转换
- NAT64使用
```

---

## 3. IPv6报文格式

### 3.1 IPv6基本头部

**固定40字节头部**：

```
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|Version| Traffic Class |           Flow Label                  |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|         Payload Length        |  Next Header  |   Hop Limit   |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
+                                                               +
|                                                               |
+                         Source Address                        +
|                                                               |
+                                                               +
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
+                                                               +
|                                                               |
+                      Destination Address                      +
|                                                               |
+                                                               +
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

**字段说明**：

```
Version（版本，4位）：
- 值为6

Traffic Class（流量类别，8位）：
- 相当于IPv4的ToS
- 用于QoS

Flow Label（流标签，20位）：
- 标识一个流
- 用于QoS保证
- 同一流的包有相同标签

Payload Length（有效载荷长度，16位）：
- 载荷（数据+扩展头部）的长度
- 单位：字节
- 不包括基本头部的40字节

Next Header（下一个头部，8位）：
- 指示下一个头部的类型
- 相当于IPv4的Protocol字段
- 值：
  - 6：TCP
  - 17：UDP
  - 58：ICMPv6
  - 43：路由扩展头部
  - 44：分片扩展头部
  - 等等

Hop Limit（跳数限制，8位）：
- 相当于IPv4的TTL
- 每经过一个路由器减1
- 为0时丢弃

Source Address（源地址，128位）：
- 发送方IPv6地址

Destination Address（目的地址，128位）：
- 接收方IPv6地址
```

### 3.2 IPv6扩展头部

**扩展头部链**：

```
IPv6的灵活性：扩展头部

IPv6基本头部（40字节）
    ↓ Next Header
扩展头部1（可选）
    ↓ Next Header
扩展头部2（可选）
    ↓ Next Header
...
    ↓ Next Header
上层协议（TCP/UDP等）

优点：
✅ 只在需要时添加
✅ 提高路由效率（基本头部固定）
✅ 灵活扩展
```

**常见扩展头部**：

```
1. 逐跳选项头部（Hop-by-Hop Options）
   - Next Header = 0
   - 每个路由器都要处理

2. 路由头部（Routing Header）
   - Next Header = 43
   - 指定路由路径

3. 分片头部（Fragment Header）
   - Next Header = 44
   - 用于分片和重组

4. 目的选项头部（Destination Options）
   - Next Header = 60
   - 只有目的节点处理

5. 认证头部（Authentication Header，AH）
   - Next Header = 51
   - IPSec认证

6. 封装安全载荷（ESP）
   - Next Header = 50
   - IPSec加密

推荐顺序：
基本头部 → 逐跳 → 目的 → 路由 → 分片 → 认证 → ESP → 目的 → 上层协议
```

### 3.3 IPv6 vs IPv4报文对比

```
┌────────────────────┬──────────────┬──────────────┐
│      特性          │    IPv4      │    IPv6      │
├────────────────────┼──────────────┼──────────────┤
│ 地址长度           │   32位       │   128位      │
│ 头部长度           │  20-60字节   │   40字节     │
│ 头部格式           │   可变       │   固定       │
│ 校验和             │    有        │    无        │
│ 分片               │ 路由器可分片 │ 只有源节点   │
│ 选项               │ 头部内       │  扩展头部    │
│ 广播               │    支持      │   不支持     │
│ 多播               │    可选      │   内置       │
│ 任播               │   不支持     │   支持       │
│ IPSec              │    可选      │   强制       │
│ 配置               │ 手动/DHCP    │ 自动/DHCPv6  │
└────────────────────┴──────────────┴──────────────┘

简化：
IPv6去掉了：
❌ 头部校验和（让上层协议处理）
❌ 选项字段（改用扩展头部）
❌ 分片字段（只有源节点分片）

IPv6添加了：
✅ 流标签
✅ 扩展头部机制
✅ 更大的地址空间
```

---

## 4. IPv6地址配置

### 4.1 无状态地址自动配置（SLAAC）

**工作原理**：

```
SLAAC = Stateless Address Autoconfiguration
无状态地址自动配置

过程：

1. 生成链路本地地址
   - 前缀：fe80::/64
   - 接口ID：从MAC地址生成（EUI-64）
   - 示例：fe80::xxxx:xxxx:xxxx:xxxx

2. 重复地址检测（DAD）
   - 发送邻居请求（Neighbor Solicitation）
   - 如果无响应，地址可用

3. 路由器发现
   - 发送路由器请求（Router Solicitation）
   - 或等待路由器通告（Router Advertisement）

4. 生成全局地址
   - 从RA获取前缀（如2001:db8::/64）
   - 加上接口ID
   - 得到全局地址：2001:db8::xxxx:xxxx:xxxx:xxxx

5. 再次DAD
   - 确保全局地址唯一

完成！即插即用，无需DHCP
```

**EUI-64接口标识符**：

```
从MAC地址生成接口ID：

MAC地址（48位）：
00:1A:2B:3C:4D:5E

步骤：
1. 插入FF:FE
   00:1A:2B:FF:FE:3C:4D:5E

2. 反转第7位（本地/全球位）
   00 = 00000000
   反转第7位 = 00000010 = 02

结果：
02:1A:2B:FF:FE:3C:4D:5E

接口ID：
021a:2bff:fe3c:4d5e

完整地址：
2001:db8::021a:2bff:fe3c:4d5e

简化：
2001:db8::21a:2bff:fe3c:4d5e
```

**隐私扩展**：

```
问题：
EUI-64使用MAC地址
→ 地址包含硬件信息
→ 可以跟踪设备
→ 隐私问题

解决方案：
隐私扩展（Privacy Extensions，RFC 4941）

特点：
- 随机生成接口ID
- 定期更换
- 临时地址

结果：
主机有多个IPv6地址：
- 链路本地地址（fe80::）
- 永久全局地址（基于EUI-64）
- 临时地址（隐私扩展）
```

### 4.2 DHCPv6

**有状态配置**：

```
DHCPv6 = 类似IPv4的DHCP

使用场景：
- 需要DNS服务器地址
- 需要中央管理
- 需要特定地址分配

工作模式：

1. 有状态DHCPv6（Stateful）
   - 分配完整地址
   - 类似IPv4 DHCP

2. 无状态DHCPv6（Stateless）
   - 地址通过SLAAC获取
   - DHCPv6只提供其他信息（DNS等）

消息类型：
- SOLICIT：客户端请求
- ADVERTISE：服务器通告
- REQUEST：客户端请求地址
- REPLY：服务器响应
```

### 4.3 配置方式对比

```
┌─────────────┬──────────┬──────────┬──────────┐
│   特性      │  SLAAC   │无状态DHCPv6│有状态DHCPv6│
├─────────────┼──────────┼──────────┼──────────┤
│ 地址获取    │   RA     │    RA    │  DHCPv6  │
│ DNS获取     │   ❌     │    ✅    │    ✅    │
│ 中央管理    │   ❌     │    ❌    │    ✅    │
│ 部署复杂度  │   低     │    中    │    高    │
│ 即插即用    │   ✅     │    ✅    │    ❌    │
└─────────────┴──────────┴──────────┴──────────┘

推荐：
- 家庭网络：SLAAC
- 企业网络：有状态DHCPv6
- 混合环境：无状态DHCPv6
```

---

## 5. IPv6过渡技术

### 5.1 双栈（Dual Stack）

```
双栈 = IPv4 + IPv6同时运行

原理：
主机同时配置IPv4和IPv6地址

┌──────────────────┐
│   应用程序       │
├──────────────────┤
│  IPv4   │  IPv6  │
├──────────────────┤
│   传输层（TCP）  │
├──────────────────┤
│  物理层          │
└──────────────────┘

优点：
✅ 兼容性好
✅ 平滑过渡
✅ 应用无需修改

缺点：
❌ 需要IPv4和IPv6双份资源
❌ 管理复杂

使用场景：
- 过渡初期
- 长期共存
```

### 5.2 隧道技术（Tunneling）

**6to4隧道**：

```
IPv6数据包封装在IPv4中

原理：
[IPv6数据包]
    ↓ 封装
[IPv4头部 | IPv6数据包]
    ↓ 传输（IPv4网络）
[IPv4头部 | IPv6数据包]
    ↓ 解封装
[IPv6数据包]

类型：

1. 6to4
   - 自动隧道
   - 地址前缀：2002::/16
   - 包含IPv4地址

2. 6in4（手动隧道）
   - 手动配置
   - 点对点

3. Teredo
   - 穿越NAT
   - 地址前缀：2001:0::/32
   - Windows内置

4. ISATAP
   - 企业内部
   - 站点内自动隧道
```

### 5.3 转换技术（Translation）

**NAT64**：

```
NAT64 = IPv6 ↔ IPv4转换

场景：
IPv6客户端访问IPv4服务器

原理：
IPv6客户端
    ↓ IPv6
NAT64网关
    ↓ IPv4
IPv4服务器

地址映射：
IPv6: 64:ff9b::192.0.2.1
IPv4: 192.0.2.1

工作过程：
1. IPv6客户端访问 64:ff9b::192.0.2.1
2. NAT64提取IPv4地址：192.0.2.1
3. 转换为IPv4包，发送到服务器
4. 响应返回，转换为IPv6包
5. 发送给客户端

配合DNS64：
自动将IPv4地址映射为IPv6
```

### 5.4 过渡策略

```
推荐过渡路径：

阶段1：准备（现在）
- 学习IPv6
- 测试设备兼容性
- 规划地址

阶段2：部署双栈（1-3年）
- 启用IPv6
- 保留IPv4
- 双栈运行

阶段3：优先IPv6（3-5年）
- IPv6优先
- IPv4备用
- 逐步减少IPv4

阶段4：纯IPv6（5-10年）
- 完全IPv6
- 必要时使用转换
- IPv4淘汰

现实：
- 双栈会长期存在
- 完全过渡需要时间
- 应用和设备逐步支持
```

---

## 6. IPv6实践

### 6.1 查看IPv6地址

**Linux/macOS**：

```bash
# 查看所有IPv6地址
ip -6 addr show
ifconfig

# 查看IPv6路由表
ip -6 route show

# 测试IPv6连接
ping6 ::1
ping6 google.com

# 追踪IPv6路由
traceroute6 google.com
```

**Windows**：

```cmd
# 查看IPv6地址
ipconfig

# 测试IPv6连接
ping ::1
ping ipv6.google.com

# 追踪路由
tracert -6 google.com

# 查看IPv6路由表
netsh interface ipv6 show route
```

### 6.2 配置IPv6

**Linux**：

```bash
# 启用IPv6
sysctl -w net.ipv6.conf.all.disable_ipv6=0

# 配置静态IPv6地址
ip -6 addr add 2001:db8::1/64 dev eth0

# 配置IPv6网关
ip -6 route add default via 2001:db8::ff

# 配置文件（/etc/network/interfaces）
iface eth0 inet6 static
    address 2001:db8::1
    netmask 64
    gateway 2001:db8::ff
```

**macOS**：

```bash
# 配置IPv6地址（网络偏好设置）
# 或使用networksetup命令
networksetup -setv6manual Ethernet 2001:db8::1 64 2001:db8::ff
```

---

## 7. 实战项目：IPv6地址工具

### 7.1 项目需求

```
功能需求：
1. IPv6地址解析和验证
2. 地址压缩和扩展
3. 地址类型识别
4. EUI-64计算
5. IPv4/IPv6地址转换
6. 地址范围计算

技术要求：
- Python实现
- 命令行界面
- 支持各种IPv6格式
- 友好的输出
```

### 7.2 工具演示

```bash
# IPv6地址解析
python day23_ipv6_tool.py --parse 2001:db8::1

# 地址压缩
python day23_ipv6_tool.py --compress 2001:0db8:0000:0000:0000:0000:0000:0001

# EUI-64计算
python day23_ipv6_tool.py --eui64 00:1a:2b:3c:4d:5e --prefix 2001:db8::/64
```

---

## 8. 今日练习

### 练习1：地址压缩

```
压缩以下IPv6地址：
1. 2001:0db8:0000:0000:0000:ff00:0042:8329
2. fe80:0000:0000:0000:0000:0000:0000:0001
3. 2001:0db8:0001:0000:0000:0000:0000:0001
```

### 练习2：地址识别

```
识别以下地址类型：
1. ::1
2. fe80::1
3. ff02::1
4. 2001:db8::1
5. fd00::1
```

### 练习3：子网划分

```
将2001:db8::/32分配给：
1. 256个/40子网
2. 每个子网的/64链路
```

### 练习4：配置实践

```
1. 在本机启用IPv6
2. 配置链路本地地址
3. 测试连接
4. 查看路由表
```

---

## 9. 常见问题

**Q1：IPv6真的必要吗？**

A：
- 是的，IPv4地址已经耗尽
- NAT只是临时方案
- 物联网需要大量地址
- IPv6是长远解决方案

**Q2：何时全面部署IPv6？**

A：
- 已经在逐步部署
- 主要网站已支持
- ISP逐步提供
- 预计10-20年完全过渡

**Q3：IPv6比IPv4快吗？**

A：
- 理论上更快（简化头部）
- 实际差异不大
- 主要优势在地址空间和功能

**Q4：IPv6安全吗？**

A：
- IPSec是强制的
- 但仍需要防火墙
- 地址空间大，扫描困难
- 新协议，可能有未知漏洞

**Q5：如何测试IPv6连接？**

A：
```bash
# 访问IPv6测试网站
http://test-ipv6.com
http://ipv6-test.com

# 命令行测试
ping6 google.com
curl -6 http://ipv6.google.com
```

---

## 10. 总结

今天我们学习了：

### 核心知识点

1. **IPv6基础**：
   - 128位地址
   - 解决IPv4地址短缺
   - 简化头部，提高效率

2. **地址格式**：
   - 冒号十六进制表示
   - 压缩规则
   - 前缀表示

3. **地址类型**：
   - 单播（全局、链路本地、ULA）
   - 任播
   - 多播（无广播）

4. **报文格式**：
   - 固定40字节头部
   - 扩展头部机制
   - 简化的字段

5. **地址配置**：
   - SLAAC（自动配置）
   - DHCPv6
   - 隐私扩展

6. **过渡技术**：
   - 双栈
   - 隧道（6to4、Teredo）
   - 转换（NAT64）

### 重点回顾

```
IPv6地址：
- 128位 = 8个16位字段
- 十六进制表示
- 可以压缩零

地址类型：
- 2000::/3 - 全局单播
- fe80::/10 - 链路本地
- fc00::/7 - 唯一本地（私有）
- ff00::/8 - 多播

配置方式：
- SLAAC：自动，即插即用
- DHCPv6：中央管理
- 手动：特殊需求

过渡策略：
现在：双栈
未来：纯IPv6
```

### 明天预告

**第24天：ICMP和诊断工具**

内容预览：
- ICMP协议详解
- ICMPv6
- ping原理和实现
- traceroute原理
- 网络诊断工具

---

**继续加油！** 🚀

今天我们学习了下一代互联网协议IPv6，理解了它的设计优势和过渡策略。虽然IPv6部署需要时间，但这是网络发展的必然趋势。明天我们将学习ICMP协议，了解网络诊断工具的原理！

**进度：23/180天（12.8%）**
